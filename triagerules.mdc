---
description: 
globs: 
alwaysApply: false
---
# Cursor Rules for Triage.Flow Project

## Project Overview
This project consists of two main components:
- **Backend (src/)**: FastAPI-based Python application with AI/LLM integration, GitHub API client, RAG systems, and agentic tools
- **Frontend (issue-flow-ai-prompt/)**: React + TypeScript + Vite application using shadcn/ui components

## General Guidelines
- Follow existing code patterns and conventions within each component
- Prioritize readability and maintainability
- Use meaningful variable and function names
- Add appropriate type hints and documentation
- Handle errors gracefully with proper logging

## Python Backend (src/) Module Documentation

### Core Application Files

#### `main.py` (96 lines)
**FastAPI Application Entry Point**
- Main FastAPI application setup with CORS middleware
- Router registration for all API endpoints (chat, sessions, repository, issues, timeline, agentic)
- Background task management for session cleanup and cache maintenance
- Startup/shutdown event handlers for Redis initialization and cleanup
- Cache statistics endpoint for monitoring performance
- Health check endpoint

#### `config.py` (167 lines)
**Configuration Management**
- Pydantic-based settings class with environment variable support
- API key management (OpenAI, OpenRouter, GitHub)
- LLM provider configuration with model-specific settings
- Redis cache configuration and connection parameters
- Feature flags for experimental functionality
- Performance tuning parameters (batch sizes, concurrency limits)
- Content size limits and token-based constraints
- Agentic system configuration parameters

#### `models.py` (186 lines)
**Data Models and Schemas**
- Pydantic models for API request/response validation
- Core data structures: `Issue`, `IssueComment`, `PullRequestInfo`
- Enhanced PR models with review and status information
- Session management models: `SessionResponse`, `RepoRequest`
- Search result models: `IssueSearchResult`, `PatchSearchResult`
- Context response models for RAG operations

### AI/LLM Integration

#### `llm_client.py` (566 lines)
**LLM Provider Integration**
- Unified interface for OpenAI and OpenRouter APIs
- Token estimation and context window management
- RAG context formatting for LLM prompts
- Streaming response support for real-time interactions
- Prompt caching for performance optimization
- Model configuration management with provider-specific settings
- Error handling and retry logic for API calls

#### `agentic_rag.py` (694 lines)
**Agentic RAG System Integration**
- Combines semantic retrieval with agentic tool capabilities
- Query analysis and complexity scoring
- Multi-strategy processing (light, focused, deep enhancement)
- Integration with LocalRepoContextExtractor and AgenticCodebaseExplorer
- Asynchronous issue RAG initialization with progress tracking
- Query caching and optimization
- Context-aware tool selection based on query type

### GitHub Integration

#### `github_client.py` (858 lines)
**GitHub API Client**
- Issue fetching with caching and retry logic
- Pull request operations with enhanced metadata
- Repository listing and management
- Comment posting and issue creation
- PR review and status check integration
- Rate limiting and error handling
- Gist creation for code sharing

### RAG Systems

#### `new_rag.py` (956 lines)
**Local Repository RAG System**
- Repository cloning and indexing
- Semantic search over codebase
- File content extraction and chunking
- Language-aware processing
- Query engine with similarity search
- Context window optimization
- File pattern matching and filtering

#### `issue_rag.py` (1634 lines)
**Issue-Aware RAG System**
- GitHub issue indexing and search
- Issue similarity matching
- Patch linkage for solution discovery
- Historical issue analysis
- Label and metadata processing
- Cross-repository issue correlation
- Performance optimization with caching

#### `local_rag.py` (292 lines)
**Local RAG Utilities**
- File system traversal and indexing
- Content preprocessing and cleaning
- Chunk size optimization
- Language detection and filtering
- Directory structure analysis

### Session and State Management

#### `session_manager.py` (518 lines)
**Session Management System**
- Redis-backed session persistence
- Issue analysis session creation
- Repository-only chat sessions
- Session lifecycle management
- Conversation history tracking
- Background session cleanup
- Fallback to in-memory storage

#### `conversation_memory.py` (327 lines)
**Conversation Context Management**
- Message history persistence
- Context window management
- Memory optimization strategies
- Conversation summarization
- Thread-aware context tracking

### Caching System

#### `cache_manager.py` (198 lines)
**Cache Management Utilities**
- Cache statistics and monitoring
- TTL management
- Memory usage optimization
- Cache key generation
- Cleanup strategies

#### `chunk_store.py` (212 lines)
**Chunk Storage System**
- Content chunking strategies
- Chunk persistence and retrieval
- Size optimization
- Redis-backed storage
- Chunk expiration management

#### `cache/` Directory
- **`redis_cache_manager.py`** (441 lines): Enhanced Redis cache implementation with connection pooling
- **`benchmark.py`** (272 lines): Cache performance benchmarking tools
- **`migration.py`** (99 lines): Cache migration utilities

### Specialized Analysis Tools

#### `commit_index.py` (1128 lines)
**Git Commit Indexing System**
- Commit history analysis
- Diff processing and storage
- Author and timestamp tracking
- Commit message analysis
- File change tracking
- Performance optimization with batching

#### `patch_linkage.py` (1332 lines)
**Patch and Solution Linkage**
- Issue-to-patch correlation
- Diff analysis and summarization
- Solution pattern recognition
- Code change impact analysis
- Historical fix tracking
- Performance optimization

#### `repo_summarizer.py` (304 lines)
**Repository Analysis and Summarization**
- Codebase structure analysis
- Technology stack detection
- Project overview generation
- Key file identification
- Architecture pattern recognition

### Agentic Tools System

#### `agent_tools/` Directory
- **`core.py`** (360 lines): Base agentic system with tool execution framework
- **`agent_manager.py`** (436 lines): Agent lifecycle and coordination management
- **`context_manager.py`** (464 lines): Context sharing and enhancement between tools
- **`context_aware_tools.py`** (355 lines): Tools with enhanced context understanding
- **`tool_registry.py`** (263 lines): Tool discovery and registration system
- **`query_processor.py`** (467 lines): Query analysis and routing logic
- **`response_handling.py`** (300 lines): Response formatting and post-processing
- **`prompts.py`** (194 lines): Prompt templates and generation
- **`utilities.py`** (198 lines): Common utility functions for agents
- **`llm_config.py`** (55 lines): LLM configuration for agentic operations

#### Specialized Agent Tools
- **`issue_operations.py`** (785 lines): Issue analysis, creation, and management tools
- **`pr_operations.py`** (468 lines): Pull request analysis and operations
- **`git_operations.py`** (757 lines): Git repository operations and analysis
- **`file_operations.py`** (227 lines): File system operations and analysis
- **`search_operations.py`** (240 lines): Advanced search and discovery tools
- **`code_generation.py`** (438 lines): Code generation and modification tools

### Issue Analysis System

#### `issue_analysis/` Directory
- **`analyzer.py`** (459 lines): Core issue analysis engine with classification
- **`classifier.py`** (78 lines): Issue type and priority classification
- **`plan_generator.py`** (68 lines): Action plan generation for issues
- **`pr_checker.py`** (100 lines): PR status and merge readiness analysis

### Git Integration Tools

#### `git_tools/` Directory
- **`git_history_tools.py`** (367 lines): Git history analysis and traversal
- **`git_blame_tools.py`** (336 lines): Code authorship and change tracking
- **`issue_closing_tools.py`** (304 lines): Issue resolution tracking through commits

### Specialized Utilities

#### `triage_bot.py` (543 lines)
**Automated Triage Bot**
- Automated issue classification
- Priority assignment
- Label management
- Notification system
- Integration with GitHub webhooks

#### `founding_member_agent.py` (593 lines)
**Founding Member Agent System**
- Advanced reasoning capabilities
- Multi-step problem solving
- Context-aware decision making
- Integration with all system components

#### `prompt_generator.py` (241 lines)
**Dynamic Prompt Generation**
- Context-aware prompt creation
- Template management
- Prompt optimization
- Multi-modal prompt support

#### `repo_context.py` (155 lines)
**Repository Context Extraction**
- Project structure analysis
- Dependency mapping
- Configuration detection
- Build system identification

#### `language_config.py` (267 lines)
**Programming Language Configuration**
- Language-specific processing rules
- Syntax highlighting configuration
- File extension mapping
- Parser configuration

#### `local_repo_loader.py` (98 lines)
**Local Repository Management**
- Repository cloning and updates
- Branch management
- Local storage optimization
- Git operations wrapper

### API Layer

#### `api/` Directory
- **`dependencies.py`** (138 lines): FastAPI dependency injection setup
- **`middleware.py`** (18 lines): CORS and request middleware
- **`routers/`**: API endpoint organization by feature area

## Python Backend (src/) Rules

### Code Style & Structure
- Use Python 3.8+ features
- Follow PEP 8 style guidelines
- Use type hints for all function parameters and return values
- Prefer dataclasses or Pydantic models for data structures
- Use relative imports (e.g., `from .config import settings`)
- Place imports in this order: standard library, third-party, local imports

### FastAPI Patterns
- Use dependency injection for shared resources (session_manager, etc.)
- Group related endpoints in router modules under `api/routers/`
- Use Pydantic models for request/response validation
- Include proper HTTP status codes and error responses
- Add descriptive docstrings for API endpoints

### Configuration & Settings
- Use the existing `Settings` class in `config.py` for all configuration
- Access settings via `from .config import settings`
- Support environment variables with sensible defaults
- Use feature flags for experimental functionality

### LLM & AI Integration
- Use the existing `LLMClient` for all AI model interactions
- Support multiple providers (OpenAI, OpenRouter) via configuration
- Implement proper token counting and context window management
- Use caching for expensive LLM operations when appropriate
- Handle rate limiting and API errors gracefully

### Data Models
- Define all data structures in `models.py` using Pydantic
- Use proper type annotations and validation
- Include example values in docstrings when helpful
- Maintain backward compatibility when modifying existing models

### Caching & Performance
- Use the existing cache managers (`rag_cache`, `response_cache`, `folder_cache`)
- Implement cache keys that are deterministic and collision-free
- Set appropriate TTL values based on data volatility
- Monitor cache hit rates and memory usage

### Agentic Tools & RAG
- Follow the existing tool pattern in `agent_tools/`
- Use the `FunctionTool` base class for new tools
- Implement proper error handling in tool functions
- Maintain tool registry for discoverability
- Use chunking strategies for large content processing

### Error Handling & Logging
- Use Python's logging module with appropriate levels
- Include context in error messages (file paths, user inputs, etc.)
- Catch specific exceptions rather than broad Exception catches
- Return structured error responses with helpful messages

### Testing & Quality
- Write unit tests for new functionality
- Mock external dependencies (GitHub API, LLM providers)
- Use pytest fixtures for common test setups
- Test both success and error cases

## React Frontend (issue-flow-ai-prompt/) Rules

### Code Style & Structure
- Use TypeScript with strict mode enabled
- Prefer functional components with hooks
- Use the `@/` alias for imports (configured in tsconfig)
- Group imports: React, third-party, local components, types/interfaces

### Component Patterns
- Use shadcn/ui components as building blocks
- Create reusable components in `components/` directory
- Use proper TypeScript interfaces for props
- Implement proper error boundaries for robust UIs

### State Management
- Use React Query (@tanstack/react-query) for server state
- Use React hooks (useState, useEffect) for local state
- Implement proper loading and error states
- Cache API responses appropriately

### Styling & UI
- Use Tailwind CSS for styling with existing utility classes
- Follow the existing design system from shadcn/ui
- Use consistent spacing, colors, and typography
- Implement responsive design patterns
- Use Framer Motion for animations when appropriate

### Routing & Navigation
- Use React Router for client-side routing
- Follow RESTful URL patterns where possible
- Implement proper 404 handling
- Use React Router's type-safe navigation

### API Integration
- Create custom hooks for API calls using React Query
- Handle loading, error, and success states consistently
- Implement proper error messages and user feedback
- Use TypeScript interfaces matching backend models

### Forms & Validation
- Use React Hook Form with Zod validation
- Implement proper form error handling and display
- Use controlled components for form inputs
- Provide clear validation feedback to users

### Performance
- Use React.memo for expensive components
- Implement proper loading states to prevent layout shift
- Optimize bundle size with dynamic imports where appropriate
- Use proper keys for list rendering

### Code Organization
- Place page components in `pages/` directory
- Group related components in feature-specific folders
- Use barrel exports (index.ts) for cleaner imports
- Keep components small and focused on single responsibilities

## Cross-Cutting Concerns

### API Communication
- Maintain consistency between frontend TypeScript types and backend Pydantic models
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Implement proper request/response logging
- Handle authentication and authorization consistently

### Error Handling
- Provide user-friendly error messages
- Log detailed error information for debugging
- Implement graceful degradation for non-critical features
- Use proper HTTP status codes

### Security
- Validate all inputs on both frontend and backend
- Use environment variables for sensitive configuration
- Implement proper CORS policies
- Sanitize user-generated content

### Documentation
- Add JSDoc comments for complex functions
- Maintain up-to-date README files
- Document API endpoints with proper examples
- Include type information in all interfaces

## File Naming Conventions
- Python: snake_case for files and variables, PascalCase for classes
- TypeScript: PascalCase for components, camelCase for functions/variables
- Use descriptive names that indicate the file's purpose
- Group related files in appropriate directories

## Dependencies
- Keep dependencies up to date but test thoroughly before upgrading
- Prefer well-maintained libraries with good TypeScript support
- Document any custom or complex dependencies
- Use exact versions for critical dependencies

## Environment & Configuration
- Use `.env` files for local development
- Never commit sensitive information to version control
- Provide example environment files (`.env.example`)
- Use different configurations for development/production

Remember: When in doubt, follow the existing patterns in the codebase and prioritize consistency over personal preferences.
